% apendice.tex
\appendix
\chapter{Arquivos fonte}
\thispagestyle{fancy}

\lstset{language=Python,
basicstyle=\scriptsize,
caption={Arquivo fonte do comando gerado para o Scrapy, o \texttt{importwpt.py}}
}
\begin{lstlisting}

from scrapy.command import ScrapyCommand
from scrapy.utils.misc import load_object
from scrapy.conf import settings
from scrapy.exceptions import UsageError
from scrapy import log
from lxml import objectify
from lxml.etree import XMLSyntaxError
import re
import sys
import string

XMLNS = '{http://www.omfica.org/schemas/ow/0.9}' 

spider_template = """from scrapy.spider import BaseSpider
from scrapy.contrib.loader import XPathItemLoader

class ${spider_class}(BaseSpider):
    name = ${name}
    allowed_domains = [${name}]
    start_urls = [${start_urls}]

    def parse(self, response):
        ${item_load}
"""

item_template = """
class ${item}(Item):
    ${fields}
"""

field_template="    ${field}=Field(${default})"

item_load_template = """l = XPathItemLoader(item = TemplateExampleItem1(),response=response)
        l.add_xpath('bubble','id("ex1")/text()') 
        i = l.load_item()"""


wpt_url = "http://www.w3.org/Submission/WPT/"

log.start()

class Command(ScrapyCommand):
    """
    Do a import of a WPT file 
    """
    requires_project = True

    def syntax(self):
        return "<file.xml>"

    def short_desc(self):
        return "Create a spider based on a Website Parse Template (WPT) file"

    def add_options(self, parser):
        ScrapyCommand.add_options(self, parser)

    def run(self, args, opts):

        if len(args) != 1:
            raise UsageError()

        filename = args[0]

        try:
            template = open(filename).read()

            root = objectify.fromstring(template)
            if not self._check_if_wpt_file_has_valid_url(root):
                log.msg("ERROR: attribute 'host' of 'wpt' tag does not have a valid URL",log.ERROR)

            if not self._check_if_wpt_has_at_least_one_template_with_one_block(xml):
                log.msg("ERROR: The WPT file must have at least one template tag\
                        with one block tag. See %s for more info" % wpt_url,log.ERROR);
    
            if not self._check_if_every_template_has_at_least_one_block(xml):
                log.msg("ERROR: Every template tag must have at least one block tag",log.ERROR)
    
            if not self._check_if_every_block_has_at_least_one_html_element_reference(xml):
                log.msg("ERROR: Every block tag must have at least one \
                        specific HTML tag reference (tagid, pattern or xpath).\
                        See %s for more info" % wpt_url,log.ERROR)

            if not self._check_if_every_template_has_a_unique_name(xml):
                log.msg("ERROR: Each template's name must be unique")
            
            if not self._check_if_url_section_is_valid_if_templates_has_no_urls(xml):
                log.msg("ERROR: Every template which does not have an 'ow:url'\
                        attribute must declare it in urls section. \
                        See %s for more info" % wpt_url,log.ERROR )

        except XMLSyntaxError,e:
            log.msg("ERROR: There is a markup error in %s" %filename,log.ERROR)
        except:
            log.msg("ERROR: File not found: %s" % filename,log.ERROR)
       
    def _check_if_wpt_file_has_valid_url(self,xml):
        try:
            url = xml.attrib[XMLNS+'host']
            p = re.compile('https?://([-A-Za-z0-9+&@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&@#/%=~_()|])')
            domains = p.findall(url)
            
            if not domains: 
                return False
    
     
            domain = domains[0]

            self.domain = domain 

            if domain.__contains__('/'):
                domain = domain.split('/')[0]
     
            site_name = domain.split('.')[0]
     
            if site_name == 'www':
                site_name = domain.split('.')[1]

            self.site_name = site_name

        except:
            return False
    
        return True

    def _check_if_every_block_has_at_least_one_html_element_reference(self,xml):
        for t in xml.template:
            if not _check_if_every_block_has_at_least_one_html_element_reference(t.block):
                return False

        return True
   
    def _check_if_block_has_at_least_one_html_element_reference(self,block):
        if hasattr(block,'block'): 
            if not self._check_if_block_has_at_least_one_html_element_reference(block.block):
                return False

        for b in block:
            has_xpath = b.attrib.__contains__(XMLNS+'xpath')
            has_tagid = b.attrib.__contains__(XMLNS+'tagid')
            has_pattern = b.attrib.__contains__(XMLNS+'pattern')
            if not (has_xpath or has_tagid or has_pattern):
                return False

        return True
 
    def _check_if_every_template_has_at_least_one_block(self,xml):
        try:
            for i in range(0,xml.template.__len__()):
                if not self._template_has_block(xml,i):
                    return False
        except AttributeError:
            return False
        return True

    def _check_if_wpt_has_at_least_one_template_with_one_block(self,xml):
        return self._template_has_block(xml,0)

    def _template_has_block(self,xml,template_id):
        try:
            return hasattr(xml.template[template_id],'block')
        except AttributeError:
            return False
   
    def _check_if_every_template_has_a_unique_name(self,xml):
        template_names = []
        for t in xml.template:
            if t.attrib[XMLNS+'name'] in template_names:
                return False
            template_names.append(t.attrib[XMLNS+'name'])

        return True
    def _check_if_url_section_is_valid_if_templates_has_no_urls(self,xml):
        for t in xml.template:
            if t.attrib.__contains__(XMLNS+'url'):
                continue

            name = t.attrib[XMLNS+'name']
            urls = [u for u in xml.urls if u.attrib[XMLNS+'template']==name]

            if  len(urls)==0:
                return False

        return True

    def generate_spider_from_wpt(self,xml):
        oxml = objectify.fromstring(xml)

        item = self.get_items_from_wpt(oxml)
        t = string.Template(spider_template)
        spider_class = oxml.template.attrib[XMLNS+'name'].replace(' ','')
        name = "'"+self.domain+"'"
        start_urls = "'"+oxml.template.attrib[XMLNS+'url']+"'"
        item_load = self.get_items_load_from_wpt(oxml) 

        py = t.substitute(spider_class=spider_class,name=name,start_urls=start_urls,item_load=item_load)
        
        py = item+"\n"+py
        return py
    
    def get_items_from_wpt(self,xml):
        items = "\nfrom scrapy.item import Item, Field\n"
        blocks = xml.template.block
        class_counter = 1
        item_class_prefix = xml.template.attrib[XMLNS+'name'].replace(' ','')

        for b in blocks:
            class_name = item_class_prefix+"Item"+str(class_counter) 
            class_counter += 1
            fields = "%s = Field()" % b.attrib['name']

            t = string.Template(item_template) 
            items += t.substitute(item=class_name,fields=fields) 
        return items

    def get_items_load_from_wpt(self,xml):
        blocks = xml.template.block
        class_counter = 1
        item_class_prefix = xml.template.attrib[XMLNS+'name'].replace(' ','')
        item_load = ""
        for b in blocks:
            class_name = item_class_prefix+"Item"+str(class_counter)
            class_counter += 1
            t = string.Template(item_load_template)

            if b.attrib.__contains__(XMLNS+'tagid'):
                xpath = 'id("%s")/text()' % b.attrib[XMLNS+'tagid']
            
            field_name = b.attrib['name']

            item_load += t.substitute(class_name=class_name,field_name=field_name,xpath=xpath)

        return item_load
\end{lstlisting}

%-------------------------------------%<-------------------------------

\pagebreak

\lstset{language=Python,
basicstyle=\scriptsize,
caption={Arquivo fonte dos testes automatizados para o comando gerado para o Scrapy. Arquivo \texttt{test\_commands.py}}
}
\begin{lstlisting}

from __future__ import with_statement

import sys
import os
import subprocess
from os.path import exists, join, dirname, abspath
from shutil import rmtree
from tempfile import mkdtemp

from twisted.trial import unittest

import scrapy


class ProjectTest(unittest.TestCase):
    project_name = 'testproject'

    def setUp(self):
        self.temp_path = mkdtemp()
        self.cwd = self.temp_path
        self.proj_path = join(self.temp_path, self.project_name)
        self.proj_mod_path = join(self.proj_path, self.project_name)
        self.env = os.environ.copy()
        self.env['PYTHONPATH'] = dirname(scrapy.__path__[0])

    def tearDown(self):
        rmtree(self.temp_path)

    def call(self, *new_args, **kwargs):
        out = os.tmpfile()
        args = (sys.executable, '-m', 'scrapy.cmdline') + new_args
        return subprocess.call(args, stdout=out, stderr=out, cwd=self.cwd, \
            env=self.env, **kwargs)

    def proc(self, *new_args, **kwargs):
        args = (sys.executable, '-m', 'scrapy.cmdline') + new_args
        return subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, \
            cwd=self.cwd, env=self.env, **kwargs)


class StartprojectTest(ProjectTest):

    def test_startproject(self):
        self.assertEqual(0, self.call('startproject', self.project_name))

        assert exists(join(self.proj_path, 'scrapy.cfg'))
        assert exists(join(self.proj_path, 'testproject'))
        assert exists(join(self.proj_mod_path, '__init__.py'))
        assert exists(join(self.proj_mod_path, 'items.py'))
        assert exists(join(self.proj_mod_path, 'pipelines.py'))
        assert exists(join(self.proj_mod_path, 'settings.py'))
        assert exists(join(self.proj_mod_path, 'spiders', '__init__.py'))

        self.assertEqual(1, self.call('startproject', self.project_name))
        self.assertEqual(1, self.call('startproject', 'wrong---project---name'))


class CommandTest(ProjectTest):

    def setUp(self):
        super(CommandTest, self).setUp()
        self.call('startproject', self.project_name)
        self.cwd = join(self.temp_path, self.project_name)
        self.env['SCRAPY_SETTINGS_MODULE'] = '%s.settings' % self.project_name


class GenspiderCommandTest(CommandTest):

    def test_arguments(self):
        # only pass one argument. spider script shouldn't be created
        self.assertEqual(2, self.call('genspider', 'test_name'))
        assert not exists(join(self.proj_mod_path, 'spiders', 'test_name.py'))
        # pass two arguments <name> <domain>. spider script should be created
        self.assertEqual(0, self.call('genspider', 'test_name', 'test.com'))
        assert exists(join(self.proj_mod_path, 'spiders', 'test_name.py'))

    def test_template(self, tplname='crawl'):
        args = ['--template=%s' % tplname] if tplname else []
        spname = 'test_spider'
        p = self.proc('genspider', spname, 'test.com', *args)
        out = p.stdout.read()
        self.assert_("Created spider %r using template %r in module" % (spname, tplname) in out)
        self.assert_(exists(join(self.proj_mod_path, 'spiders', 'test_spider.py')))
        p = self.proc('genspider', spname, 'test.com', *args)
        out = p.stdout.read()
        self.assert_("Spider %r already exists in module" % spname in out)

    def test_template_basic(self):
        self.test_template('basic')

    def test_template_csvfeed(self):
        self.test_template('csvfeed')

    def test_template_xmlfeed(self):
        self.test_template('xmlfeed')

    def test_list(self):
        self.assertEqual(0, self.call('genspider', '--list'))

    def test_dump(self):
        self.assertEqual(0, self.call('genspider', '--dump=basic'))
        self.assertEqual(0, self.call('genspider', '-d', 'basic'))


class MiscCommandsTest(CommandTest):

    def test_crawl(self):
        self.assertEqual(0, self.call('crawl'))

    def test_list(self):
        self.assertEqual(0, self.call('list'))

class RunSpiderCommandTest(CommandTest):

    def test_runspider(self):
        tmpdir = self.mktemp()
        os.mkdir(tmpdir)
        fname = abspath(join(tmpdir, 'myspider.py'))
        with open(fname, 'w') as f:
            f.write("""
from scrapy import log
from scrapy.spider import BaseSpider

class MySpider(BaseSpider):
    name = 'myspider'

    def start_requests(self):
        self.log("It Works!")
        return []
""")
        p = self.proc('runspider', fname)
        log = p.stderr.read()
        self.assert_("[myspider] DEBUG: It Works!" in log)
        self.assert_("[myspider] INFO: Spider opened" in log)
        self.assert_("[myspider] INFO: Closing spider (finished)" in log)
        self.assert_("[myspider] INFO: Spider closed (finished)" in log)

    def test_runspider_no_spider_found(self):
        tmpdir = self.mktemp()
        os.mkdir(tmpdir)
        fname = abspath(join(tmpdir, 'myspider.py'))
        with open(fname, 'w') as f:
            f.write("""
from scrapy import log
from scrapy.spider import BaseSpider
""")
        p = self.proc('runspider', fname)
        log = p.stderr.read()
        self.assert_("No spider found in file" in log)

    def test_runspider_file_not_found(self):
        p = self.proc('runspider', 'some_non_existent_file')
        log = p.stderr.read()
        self.assert_("File not found: some_non_existent_file" in log)

    def test_runspider_unable_to_load(self):
        tmpdir = self.mktemp()
        os.mkdir(tmpdir)
        fname = abspath(join(tmpdir, 'myspider.txt'))
        with open(fname, 'w') as f:
            f.write("")
        p = self.proc('runspider', fname)
        log = p.stderr.read()
        self.assert_("Unable to load" in log)


class ImportWptCommandTest(CommandTest):

    def test_import_file_not_found(self):
        p = self.proc("importwpt","some_non_existent_file")
        log = p.stderr.read()
        self.assert_("ERROR: File not found: some_non_existent_file" in log,'Log contents: '+log)

    def test_import_existent_file_invalid_markup(self):
        tmpdir = self.mktemp()
        os.mkdir(tmpdir)
        fname = abspath(join(tmpdir,"mytemplate.xml"))
        open(fname,"w").write("")
        p = self.proc("importwpt",fname)
        log = p.stderr.read()

        self.assert_(("ERROR: There is a markup error in %s" % fname) in log,'Log contents: '+log)

    def _test_import_valid_markup_with_no_template_tag(self):
        tmpdir = self.mktemp()
        os.mkdir(tmpdir)
        fname = abspath(join(tmpdir,"mytemplate.xml"))
        
        xml = '<?xml version="1.0" encoding="UTF-8"?>\
                     <ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                                ow:host="http://www.example.com"> \
                     </ow:wpt>'
        
        with open(fname,"w") as f:
            f.write(xml)
            p = self.proc('importwpt',fname)
            log = p.stderr.read()

        self.assert_("ERROR: The WPT file must have at least one template tag\
                        with one block tag." in log,"log contents %s" % log)

    def test_validate_business_rules(self):
        from lxml import objectify
        from scrapy.commands.importwpt import Command

        cmd = Command()
        
        "_check_if_wpt_file_has_valid_url"
        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9"></ow:wpt>'
        
        oxml = objectify.fromstring(xml)
        check = cmd._check_if_wpt_file_has_valid_url(oxml)
        self.assert_(not check)
 
        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                ow:host="http://example.com"></ow:wpt>'

        oxml = objectify.fromstring(xml)
        check = cmd._check_if_wpt_file_has_valid_url(oxml)
        self.assert_(check)

        "_check_if_wpt_has_at_least_one_template_with_one_block"
        
        check = cmd._check_if_wpt_has_at_least_one_template_with_one_block(oxml)
        self.assert_(not check)
        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                ow:host="http://example.com">\
                <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                    <ow:block></ow:block> \
                </ow:template> \
                </ow:wpt>'
        oxml = objectify.fromstring(xml)
        check = cmd._template_has_block(oxml,0) 
        self.assert_(check)

        check = cmd._check_if_wpt_has_at_least_one_template_with_one_block(oxml)
        self.assert_(check)
        
        "_check_if_block_has_at_least_one_html_element_reference"
        check = cmd._check_if_block_has_at_least_one_html_element_reference(oxml.template.block)
        self.assert_(not check)

        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                ow:host="http://example.com">\
                <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                    <ow:block ow:tagid="ex1"></ow:block> \
                </ow:template> \
                </ow:wpt>'

        oxml = objectify.fromstring(xml)
        check = cmd._check_if_block_has_at_least_one_html_element_reference(oxml.template.block) 
        self.assert_(check)

        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                 ow:host="http://example.com">\
                 <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                     <ow:block ow:tagid="ex1"> \
                        <ow:block></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 </ow:wpt>'
        oxml = objectify.fromstring(xml)
        check = cmd._check_if_block_has_at_least_one_html_element_reference(oxml.template.block)

        self.assert_(not check)
        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                 ow:host="http://example.com">\
                 <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 </ow:wpt>'
        oxml = objectify.fromstring(xml)
        check = cmd._check_if_block_has_at_least_one_html_element_reference(oxml.template.block)
        self.assert_(check)


        "_check_if_every_template_has_a_unique_name"
        check = cmd._check_if_every_template_has_a_unique_name(oxml)
        self.assert_(check)
        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                 ow:host="http://example.com">\
                 <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 </ow:wpt>'

        oxml = objectify.fromstring(xml)
        check = cmd._check_if_every_template_has_a_unique_name(oxml)
        self.assert_(not check)

        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                 ow:host="http://example.com">\
                 <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 <ow:template ow:name="Template Example 2" ow:url="http://www.example.com/index.php"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 </ow:wpt>'

        oxml = objectify.fromstring(xml)
        check = cmd._check_if_every_template_has_a_unique_name(oxml)
        self.assert_(check)

        "_check_if_url_section_is_valid_if_templates_has_no_urls"
        check = cmd._check_if_url_section_is_valid_if_templates_has_no_urls(oxml)
        self.assert_(check)

        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                 ow:host="http://example.com">\
                 <ow:template ow:name="Template Example"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 <ow:template ow:name="Template Example 2" ow:url="http://www.example.com/index2.php"> \
                     <ow:block ow:tagid="ex1"> \
                        <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 <ow:urls ow:name="Another Template" ow:template="Another Template"> \
                    <ow:url>http://www.example.com/index.php</ow:url> \
                 </ow:urls> \
                 </ow:wpt>'
        
        oxml = objectify.fromstring(xml)
        check = cmd._check_if_url_section_is_valid_if_templates_has_no_urls(oxml)
        self.assert_(not check)

        xml = '<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9" \
                 ow:host="http://example.com">\
                 <ow:template ow:name="Template Example"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 <ow:template ow:name="Template Example 2" ow:url="http://www.example.com/index2.php"> \
                     <ow:block ow:tagid="ex1"> \
                         <ow:block ow:xpath="/html/body/div/"></ow:block> \
                     </ow:block> \
                 </ow:template> \
                 <ow:urls ow:name="Template Example" ow:template="Template Example"> \
                    <ow:url>http://www.example.com/index.php</ow:url> \
                 </ow:urls> \
                 </ow:wpt>'

        oxml = objectify.fromstring(xml)
        check = cmd._check_if_url_section_is_valid_if_templates_has_no_urls(oxml)
        self.assert_(check)

    def test_template_generation(self):
        from lxml import objectify
        from scrapy.commands.importwpt import Command

        cmd = Command()

        xml = """<ow:wpt xmlns:ow="http://www.omfica.org/schemas/ow/0.9"
                            ow:host="http://example.com">
                   <ow:template ow:name="Template Example" ow:url="http://www.example.com/index.php">
                      <ow:block ow:tagid="ex1" name="ex1"></ow:block>
                    </ow:template> 
                 </ow:wpt>
             """
        py = """
from scrapy.item import Item, Field

class TemplateExampleItem1(Item):
    ex1 = Field()

from scrapy.spider import BaseSpider
from scrapy.contrib.loader import XPathItemLoader

class TemplateExample(BaseSpider):
    name = 'example.com'
    allowed_domains = ['example.com']
    start_urls = ['http://www.example.com/index.php']

    def parse(self, response):
        l = XPathItemLoader(item = TemplateExampleItem1(),response=response)
        l.add_xpath('bubble','id("ex1")/text()') 
        i = l.load_item()
"""
        self.assert_(cmd._check_if_wpt_file_has_valid_url(objectify.fromstring(xml)))
        spider = cmd.generate_spider_from_wpt(xml)
        self.assertEqual(spider,py)

\end{lstlisting}

\chapter{Glossário de termos do Git}

O seguinte glossário foi introduzido neste texto com o intuito de servir de base de pesquisa para termos relacionados ao sistema de controle de versão Git e foi adaptado de \cite{git_glossary}.

\subsubsection{alternate object database}

Via the alternates mechanism, a repository can inherit part of its object database from another object database, which is called alternate.

\subsubsection{bare repository}

A bare repository is normally an appropriately named directory with a .git suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the git administrative and control files that would normally be present in the hidden .git sub-directory are directly present in the repository.git directory instead, and no other files are present and checked out i.e. no working directory etc. Usually publishers of public repositories make bare repositories available.

\subsubsection{blob object}

Untyped object, e.g. the contents of a file.

\subsubsection{branch}

A non-cyclical graph of revisions, i.e. the complete history of a particular revision, which is called the branch head. The branch heads are stored in \$GIT\_DIR/refs/heads/.
A branch is an active line of development. The most recent commit on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch head, which moves forward as additional development is done on the branch. A single git repository can track an arbitrary number of branches, but your working tree is associated with just one of them (the current or checked out branch), and HEAD points to that branch.

\subsubsection{cache}

Obsolete for index.

\subsubsection{chain}

A list of objects, where each object in the list contains a reference to its successor (for example, the successor of a commit could be one of its parents).

\subsubsection{changeset}

BitKeeper/cvsps speak for commit. Since git does not store changes, but states, it really does not make sense to use the term changesets with git.

\subsubsection{checkout}

The action of updating the working tree to a revision which was stored in the object database.
cherry-picking
In SCM jargon, cherry pick means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of different codebase. In GIT, this is performed by git cherry-pick command to extract the change introduced by an existing commit and to record it based on the tip of the current branch as a new commit.

\subsubsection{clean}

A working tree is clean, if it corresponds to the revision referenced by the current head. Also see dirty.

\subsubsection{commit}

As a noun: A single point in the git history; the entire history of a project is represented as a set of interrelated commits. The word commit is often used by git in the same places other revision control systems use the words revision or version. Also used as a short hand for commit object.
As a verb: The action of storing a new snapshot of the project's state in the git history, by creating a new commit representing the current state of the index and advancing HEAD to point at the new commit.

\subsubsection{commit object}

An object which contains the information about a particular revision, such as parents, committer, author, date and the tree object which corresponds to the top directory of the stored revision.

\subsubsection{core git}

Fundamental data structures and utilities of git. Exposes only limited source code management tools.
DAG
Directed acyclic graph. The commit objects form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no chain which begins and ends with the same object).

\subsubsection{dangling object}

An unreachable object which is not reachable even from other unreachable objects; a dangling object has no references to it from any reference or object in the repository. See here for more information.
detached HEAD
Normally the HEAD stores the name of a branch. However, git also allows you to check out an arbitrary commit that is not necessarily the tip of any particular branch. In this case HEAD is said to be detached.

\subsubsection{dircache}

See index.

\subsubsection{directory}

The list you get with ls.

\subsubsection{dirty}

A working tree is said to be dirty if it contains modifications which have not been committed to the current branch.

\subsubsection{ent}

Favorite synonym to tree-ish by some total geeks. Avoid this term, in order to not to confuse people.

\subsubsection{evil merge}

An evil merge is a merge that introduces changes that do not appear in any parent.

\subsubsection{fast forward}

A fast-forward is a special type of merge where you have a revision and you are merging another branch's changes that happen to be a descendant of what you have. In such these cases, you do not make a new merge commit but instead just update to his revision. This will happen frequently on a tracking branch of a remote repository.

\subsubsection{fetch}

Fetching a branch means to get the branch's head ref from a remote repository, to find out which objects are missing from the local object database, and to get them, too. See also man 1 git-fetch.

\subsubsection{file system}

Linus Torvalds originally designed git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of git.

\subsubsection{git archive}

Synonym for repository (for arch people).

\subsubsection{grafts}

Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make git pretend the set of parents a commit has is different from what was recorded when the commit was created. Configured via the .git/info/grafts file.

\subsubsection{hash}

In GIT's context, synonym to object name.

\subsubsection{head}

A named reference to the commit at the tip of a branch. Heads are stored in \$GIT\_DIR/refs/heads/, except when using packed refs. (See man 1 git-pack-refs.)

\subsubsection{HEAD}

The current branch. In more detail: Your working tree is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the heads in your repository, except when using a detached HEAD, in which case it may reference an arbitrary commit.

\subsubsection{head ref}

A synonym for head.

\subsubsection{hook}

During the normal execution of several GIT commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the \$GIT\_DIR/hooks/ directory, and are enabled by simply removing the .sample suffix. More information can be found with man 5 githooks.

\subsubsection{index}

A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your working tree. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when merging.
index entry
The information regarding a particular file, stored in the index. An index entry can be unmerged, if a merge was started, but not yet finished (i.e. if the index contains multiple versions of that file).

\subsubsection{master}

The default development branch. Whenever we create a git repository, a branch named master is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.

\subsubsection{merge}

As a verb: To bring the contents of another branch (possibly from an external repository) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first fetching the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a pull. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge.
As a noun: unless it is a fast forward, a successful merge results in the creation of a new commit representing the result of the merge, and having as parents the tips of the merged branches. This commit is referred to as a merge commit, or sometimes just a merge.

\subsubsection{merge base}

The common ancestor of two or more commits.

\subsubsection{object}

The unit of storage in git. It is uniquely identified by the SHA1 of its contents. Consequently, an object can not be changed without changing its SHA1 hash.

\subsubsection{object database}

Stores a set of objects, and an individual object is identified by its object name. The objects usually live in \$GIT\_DIR/objects/.

\subsubsection{object identifier}

Synonym for object name.

\subsubsection{object name}

The unique identifier of an object. The hash of the object's contents using the SHA1 (Secure Hash Algorithm 1) and usually represented by the 40 character hexadecimal encoding of the hash of the object (possibly followed by a white space).

\subsubsection{object type}

One of the identifiers commit, tree, tag or blob describing the type of an object.

\subsubsection{octopus}

To merge more than two branches (tentacles) into one resulting branch (head) — thus the octopus metaphor.
origin
The default upstream repository. Most projects have at least one upstream project which they track. By default origin is used for that purpose. New upstream updates will be fetched into remote tracking branches named origin/name-of-upstream-branch, which you can see using git branch -r.

\subsubsection{pack}

A set of objects which have been compressed into one file (to save space or to transmit them efficiently).
pack index
The list of identifiers, and other information, of the objects in a pack to assist in efficiently accessing the contents of a pack.

\subsubsection{parent}

A commit object contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents.

\subsubsection{pickaxe}

The term pickaxe refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the \texttt{pickaxe-all} option, it can be used to view the full changeset that introduced or removed, say, a particular line of text. See man 1 git-diff.

\subsubsection{plumbing}

Cute name for core git.

\subsubsection{porcelain}

Cute name for programs and program suites depending on core git, presenting a high level access to core git. Porcelains expose more of a SCM interface than the plumbing.

\subsubsection{pull}

Pulling a branch means to fetch it and merge it. See also man 1 git-pull.

\subsubsection{push}

Pushing a branch means to get the branch's head ref from a remote repository, find out if it is an ancestor to the branch's local head ref is a direct, and in that case, putting all objects, which are reachable from the local head ref, and which are missing from the remote repository, into the remote object database, and updating the remote head ref. If the remote head is not an ancestor to the local head, the push fails.

\subsubsection{reachable}

All of the ancestors of a given commit are said to be reachable from that commit. More generally, one object is reachable from another if we can reach the one from the other by a chain that follows tags to whatever they tag, commits to their parents or trees, and trees to the trees or blobs that they contain.

\subsubsection{rebase}

To reapply a series of changes from a branch to a different base, and reset the head of that branch to the result.

\subsubsection{ref}

A 40-byte hex representation of a SHA1 or a name that denotes a particular object. These may be stored in \$GIT\_DIR/refs/.

\subsubsection{reflog}

A reflog shows the local history of a ref. It is a mechanism to record when the tip of branches are updated. In other words, it can tell you things like what the 3rd last revision in this repository was, and what was the current state in this repository, yesterday 9:14pm. See man 1 git-reflog for details. See here for when a reflog might turn out to be useful.

\subsubsection{refspec}

A refspec is used by git fetch and git push to describe the mapping between remote refs and local refs. They are combined with a colon in the format <src>:<dst>, preceded by an optional plus sign, +. For example: git fetch \$URL refs/heads/master:refs/heads/origin means grab the master branch head from the \$URL and store it as my origin branch head. And git push \$URL refs/heads/master:refs/heads/to-upstream means publish my master branch head as to-upstream branch at \$URL. See also man 1 git-push.

\subsubsection{repository}

A collection of refs together with an object database containing all objects which are reachable from the refs, possibly accompanied by meta data from one or more porcelains. A repository can share an object database with other repositories via alternates mechanism.

\subsubsection{resolve}

The action of fixing up manually what a failed automatic merge left behind.

\subsubsection{revision}

A particular state of files and directories which was stored in the object database. It is referenced by a commit object.

\subsubsection{rewind}

To throw away part of the development, i.e. to assign the head to an earlier revision.

\subsubsection{SCM}

Software Configuration Management. As a noun, it mostly describes a particular tool or set of tools. As a verb it is understood as literally doing software configuration and along with various management tasks.

\subsubsection{SHA1 (Secure Hash Algorithm 1)}

SHA1 hash. And in GIT context a synonym for object name.

\subsubsection{shallow repository}

A shallow repository has an incomplete history some of whose commits have parents cauterized away (in other words, git is told to pretend that these commits do not have the parents, even though they are recorded in the commit object). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the \texttt{depth} option to git-clone(1), and its history can be later deepened with git-fetch(1).

\subsubsection{symref}

Symbolic reference: instead of containing the SHA1 id itself, it is of the format ref: refs/some/thing and when referenced, it recursively dereferences to this reference. HEAD is a prime example of a symref. Symbolic references are manipulated with the git-symbolic-ref(1) command.

\subsubsection{tag}

A ref pointing to a tag or commit object. In contrast to a head, a tag is not changed by a commit. Tags (not tag objects) are stored in \$GIT\_DIR/refs/tags/. A git tag has nothing to do with a Lisp tag (which would be called an object type in GIT's context). A tag is most typically used to mark a particular point in the commit ancestry chain.

\subsubsection{tag object}

An object containing a ref pointing to another object, which can contain a message just like a commit object. It can also contain a (GPG/PGP) signature, in which case it is called a signed tag object.

\subsubsection{topic branch}

A regular git branch that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes.

\subsubsection{tracking branch}

A regular git branch that is used to follow changes from another repository. A tracking branch should not contain direct modifications or have local commits made to it. A tracking branch can usually be identified as the right-hand-side ref in a Pull: refspec.

\subsubsection{tree}

Either a working tree, or a tree object together with the dependent blob and tree objects (i.e. a stored representation of a working tree).

\subsubsection{tree object}

An object containing a list of file names and modes along with refs to the associated blob and/or tree objects. A tree is equivalent to a directory.

\subsubsection{tree-ish}

A ref pointing to either a commit object, a tree object, or a tag object.

\subsubsection{unmerged index}

An index which contains unmerged index entries.

\subsubsection{unreachable object}

An object which is not reachable from a branch, tag, or any other reference.

\subsubsection{working tree}

The tree of actual checked out files. The working tree is normally equal to the HEAD plus any local changes that you have made but not yet committed.